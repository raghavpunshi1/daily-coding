===============================
ARRAYS – INTERVIEW MASTER CHECKLIST
(for 2–3 year Java Software Engineer)
===============================

GOAL:
If I master EVERYTHING in this file,
I should not fail ANY array interview question.

--------------------------------
1. CORE THEORY (MUST ANSWER VERBALLY PERFECTLY)
--------------------------------

1. What is an array?
- Contiguous block of memory storing same-type elements.
- Index access: address = base + index * element_size → O(1)

2. Time Complexity:
- Access: O(1)
- Search unsorted: O(n)
- Search sorted (binary): O(log n)
- Insert/delete at index: O(n)
- Append in dynamic array (ArrayList): amortized O(1)

3. Space:
- Array uses O(n) space
- In-place algorithm = O(1) extra space

4. Why arrays are fast:
- Contiguous memory → cache friendly → fewer cache misses

5. Static vs Dynamic arrays:
- Static: fixed size
- Dynamic (ArrayList): resizes (usually doubles) → amortized O(1) add

6. Java specifics:
- int[] vs Integer[] → boxing cost, null allowed in Integer[]
- 2D arrays in Java are array-of-arrays (not contiguous)
- Arrays.sort():
   - primitives → Dual Pivot QuickSort (not stable)
   - objects → TimSort (stable)

7. Common APIs:
- Arrays.sort(arr)
- Arrays.copyOf(arr, n)
- System.arraycopy()
- arr.clone()
- Arrays.fill()
- Arrays.equals()

--------------------------------
2. ABSOLUTE CORE PATTERNS (THIS IS WHAT INTERVIEWERS TEST)
--------------------------------

If I identify pattern fast → I clear interview.

PATTERN 1: TWO POINTERS
Use when:
- Sorted array
- Pairs / reverse / partition / remove duplicates

Problems:
- Two Sum (sorted)
- Remove duplicates from sorted array
- Container with most water
- Reverse array
- Partition by condition

Template:
l = 0, r = n-1
while(l < r):
   if condition:
      l++
   else:
      r--

--------------------------------------------------

PATTERN 2: SLIDING WINDOW
Use when:
- Contiguous subarray
- Max / min / length / sum with constraint

Fixed window:
- Max sum subarray of size k

Variable window:
- Min length subarray ≥ target
- Longest substring with K distinct

Template:
l = 0
for r in range(n):
   add arr[r]
   while condition broken:
      remove arr[l]
      l++
   update answer

--------------------------------------------------

PATTERN 3: PREFIX SUM + HASHMAP
Use when:
- Subarray sum / count / range queries

Key idea:
prefix[i] = sum(0..i)

Use hashmap:
map[prefix] = count

Problems:
- Subarray sum equals K
- Count subarrays with sum K
- Equal 0s and 1s (convert 0→-1)

--------------------------------------------------

PATTERN 4: SORT + TWO POINTER
Use when:
- k-sum problems
- Closest pairs
- Remove duplicates

Problems:
- 3Sum
- 4Sum
- 3Sum closest

--------------------------------------------------

PATTERN 5: CYCLIC SORT / INDEX PLACEMENT
Use when:
- Values in range 1..n or 0..n-1

Idea:
Place each number at its correct index.

Problems:
- First missing positive
- Find duplicates
- Set mismatch

--------------------------------------------------

PATTERN 6: KADANE / SUBARRAY DP
Use when:
- Max / min subarray sum or product

Key:
maxEndingHere
maxSoFar

--------------------------------------------------

PATTERN 7: QUICKSELECT / PARTITION
Use when:
- Kth largest / smallest
- Top K

--------------------------------------------------

PATTERN 8: MONOTONIC DEQUE
Use when:
- Sliding window maximum
- Subarray with bounded max-min

--------------------------------
3. MUST-KNOW ALGORITHMS (CODE FROM MEMORY)
--------------------------------

1. KADANE – MAX SUBARRAY SUM

int maxHere = a[0], maxSoFar = a[0];
for i = 1..n-1:
   maxHere = max(a[i], maxHere + a[i])
   maxSoFar = max(maxSoFar, maxHere)

Explain:
- Either extend previous subarray or start new.

--------------------------------

2. TWO SUM (UNSORTED)

Map<Integer, Integer> map;
for i:
   if map contains (target - a[i]):
       return indices
   map.put(a[i], i)

--------------------------------

3. TWO SUM (SORTED)

l = 0, r = n-1
while l < r:
   s = a[l] + a[r]
   if s == target → found
   else if s < target → l++
   else → r--

--------------------------------

4. PRODUCT OF ARRAY EXCEPT SELF

prefix[0] = 1
for i = 1..n-1:
   prefix[i] = prefix[i-1] * a[i-1]

suffix = 1
for i = n-1..0:
   result[i] = prefix[i] * suffix
   suffix *= a[i]

--------------------------------

5. ROTATE ARRAY IN-PLACE (RIGHT K)

k = k % n
reverse(0, n-1)
reverse(0, k-1)
reverse(k, n-1)

--------------------------------

6. DUTCH NATIONAL FLAG (0,1,2 SORT)

low=0, mid=0, high=n-1
while mid <= high:
   if a[mid]==0 → swap(low,mid); low++; mid++
   else if a[mid]==1 → mid++
   else → swap(mid,high); high--

--------------------------------

7. FIRST MISSING POSITIVE (CYCLIC SORT)

for i in 0..n-1:
   while a[i] in [1..n] AND a[i] != a[a[i]-1]:
       swap(i, a[i]-1)

then scan for first a[i] != i+1

--------------------------------

8. QUICKSELECT (KTH LARGEST CORE)

partition(arr, l, r):
   pivot = arr[r]
   i = l
   for j = l..r-1:
      if arr[j] <= pivot:
         swap(i,j); i++
   swap(i,r)
   return i

--------------------------------

9. SLIDING WINDOW MAX (DEQUE)

Use deque storing indices
Remove smaller from back
Remove out-of-window from front

--------------------------------
4. TOP 25 QUESTIONS THAT DECIDE INTERVIEWS
--------------------------------

(If I solve all of these confidently → I am interview ready)

BASICS:
1. Two Sum
2. Best Time to Buy and Sell Stock
3. Remove Duplicates from Sorted Array
4. Rotate Array
5. Move Zeroes
6. Contains Duplicate
7. Single Number (XOR)

CORE PATTERNS:
8. Maximum Subarray (Kadane)
9. Product of Array Except Self
10. Subarray Sum Equals K
11. Minimum Size Subarray Sum
12. Longest Substring Without Repeating Characters
13. Sliding Window Maximum
14. Container With Most Water

SORT + POINTER:
15. 3Sum
16. 3Sum Closest
17. Merge Intervals

CYCLIC / INDEX:
18. First Missing Positive
19. Find Duplicate Number

ADVANCED BUT VERY COMMON:
20. Kth Largest Element in Array
21. Trapping Rain Water
22. Next Permutation
23. Count Inversions
24. Median of Two Sorted Arrays
25. Longest Subarray with At Most K Distinct

--------------------------------
5. THEORY QUESTIONS INTERVIEWERS LOVE
--------------------------------

Be ready to answer these:

- Why array access is O(1)?
- Difference between array and ArrayList?
- Explain amortized O(1) in dynamic array.
- Why arrays faster than linked list?
- Difference between subarray and subsequence?
- Explain Kadane’s correctness.
- When do you prefer sorting vs hashing?
- Why sliding window works only on contiguous subarrays?
- When does two-pointer fail?
- Explain time/space tradeoffs.

--------------------------------
6. EDGE CASES THEY CHECK
--------------------------------

Always mention & test:

- Empty array
- Single element
- All negative (Kadane)
- Overflow → use long
- Duplicates handling
- k > n (window problems)
- Negative numbers in sliding window (window fails sometimes)

--------------------------------
7. INTERVIEW STRATEGY (VERY IMPORTANT)
--------------------------------

When problem is given:

STEP 1:
- Clarify constraints (n size, negatives allowed, sorted?)

STEP 2:
- Identify pattern OUT LOUD:
  "This looks like sliding window / two pointers / prefix sum"

STEP 3:
- State target complexity:
  "I’ll aim for O(n) time, O(1) space"

STEP 4:
- Dry run on example

STEP 5:
- Code clean + explain invariants

STEP 6:
- Final complexity + edge cases

--------------------------------
8. FINAL SELF-CHECK BEFORE INTERVIEW
--------------------------------

I AM READY IF:

[ ] I can code Kadane in 30 seconds
[ ] I instantly recognize sliding window problems
[ ] I can do 3Sum without thinking
[ ] I can explain prefix sum + hashmap logic
[ ] I can rotate array in-place
[ ] I can do first missing positive
[ ] I can implement quickselect partition
[ ] I can explain amortized O(1)
[ ] I can speak confidently about edge cases

===============================
END OF FILE
===============================
